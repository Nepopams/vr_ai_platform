# ADR-003: Политика моделей и реестр LLM-конфигураций для агентов

- Status: Proposed
- Date: 2026-01-12
- Related ADRs:
  - ADR-000: `docs/adr/ADR-000-ai-platform-intent-decision-engine.md`
  - ADR-001: `docs/adr/ADR-001-contract-versioning-compatibility-policy.md`
  - ADR-002: `docs/adr/ADR-002-agent-model-execution-boundaries-mvp.md`
- Scope: internal runtime (agent_runner / LLM usage). Не часть внешних контрактов.

## Д — Контекст и цели

Платформа всё чаще содержит LLM-зависимые шаги: от простой нормализации до сложных цепочек. Сейчас выбор модели и параметров разнесён по коду/ENV, что приводит к непредсказуемости качества, стоимости и усложняет замену модели в нескольких агентах.

Цели (MVP):

- Ввести единый управляемый способ выбора моделей на уровне LLM-task (а не intent).
- Стандартизировать эскалацию: дешёвая модель → валидация → 1 repair → надёжная модель.
- Не менять contracts/DecisionDTO/graphs и поведение MVP.

Цели (зрелая система):

- Централизованная governance-политика (бюджеты, квоты, аудит, canary/A-B).
- Контроль качества и сравнение профилей без релиза платформы.

Не-цели:

- Новый внешний контракт или изменение DecisionDTO/graphs/contracts.
- Полный Model Registry Service в MVP.

## О — Варианты решения

O1: Хардкод/ENV в каждом агенте
- Плюсы: быстро.
- Минусы: хаос конфигураций, нет общей политики и эскалации.

O2: Единый набор ENV на весь рантайм
- Плюсы: просто.
- Минусы: нет дифференциации по сложности задач.

O3: File-based Model Policy Registry в репозитории
- Плюсы: управляемо, прозрачно, легко ревьюить, согласуется с agent_registry.
- Минусы: изменения требуют доставки файла, нужен валидатор.

O4: DB-backed конфиг
- Плюсы: изменение без релиза.
- Минусы: инфраструктурная сложность и риск ошибочной политики.

O5: Policy Service
- Плюсы: полноценная governance-модель.
- Минусы: дорого и избыточно для MVP.

## Р — Решение

### MVP решение

Принимаем O3: file-based llm-policy.yaml как внутренний derived-артефакт. Реестр выключен по умолчанию и включается флагом. При включении — fail-fast валидатор.

Политика применяется на уровне LLM-task (intent не является уровнем выбора модели):

- intent: `add_shopping_item` (продуктовая семантика)
- llm-task: `shopping_extraction` (техническая операция)

Эскалация (минимум для MVP):

1. Профиль cheap.
2. Валидация результата (JSON parse + schema + required fields).
3. 1 repair retry.
4. Эскалация на reliable.
5. При провале — нормализованный `llm_error`, дальше решает вызывающий код.

### Зрелое решение (эволюция)

Переход к O4/O5 при триггерах:

- ≥3–5 LLM-задач в проде;
- есть потребность менять модели без релиза;
- нужны бюджеты/квоты/аудит/канареечные раскатки.

Целевой вариант — Policy Service, либо DB-backed как промежуточный этап.

## А — Аспекты и политики поддержки

### A1. Размещение и формат

Файл: `llm_policy/llm-policy.yaml` (или отдельная директория). Не размещать в `contracts/`, чтобы не вводить ложный контрактный статус.

### A2. Совместимость и изменения

Реестр — internal runtime-артефакт. Любое добавление LLM-task или изменение escalation требует обновления docs и тестов. В MVP изменения политики релизятся вместе с кодом.

### A3. Валидация и fail-fast

При `LLM_POLICY_ENABLED=true`:

- отсутствие файла, невалидный YAML или несовместимый `schema_version` → ошибка старта.

### A4. Escalation и обработка ошибок

Эскалация ограничена, не бесконечна и детерминирована. Ошибки LLM нормализуются как `llm_error/invalid_output`.

### A5. Наблюдаемость и приватность

Логируем только метрики: provider/model/latency/status/error.type/tokens (если доступны). Не логируем raw user text, извлечённые данные и секреты.

### A6. Тестирование

Только unit-тесты без реальных сетевых вызовов: загрузка/валидация YAML, выбор профиля, эскалация invalid_output → repair → reliable.

### A7. Риски и trade-offs

- Плюсы: управляемая стоимость/качество, единый паттерн эскалации, простая интеграция с текущей архитектурой.
- Минусы: дисциплина задач vs intents, релизный цикл для изменений, best-effort structured output у OSS/OpenAI-compatible провайдеров.

### A8. Решение в одном абзаце

В MVP вводим file-based реестр политики моделей (tasks → profiles → provider/model/params + escalation) как internal derived-артефакт, включаемый флагом с fail-fast валидацией. В зрелой системе эволюционируем к централизованной политике (DB/Service) при достижении триггеров по числу задач, необходимости изменений без релиза и требований governance.
